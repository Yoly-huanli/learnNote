[toc]

# 一个程序是怎么运行的

**编写代码**：程序员用高级编程语言（如Python、Java、C++等）编写源代码。

**编译或解释**：

- **编译**：对于编译型语言，源代码需要经过编译器编译成机器码（目标代码），生成可执行文件（如`.exe`文件）。
- **解释**：对于解释型语言，代码通常在运行时由解释器逐行解释和执行，不会生成独立的可执行文件。

**加载**：当程序被启动时，操作系统将其可执行文件加载到内存中。这个过程包括分配内存空间、初始化数据结构等。

**执行**：CPU 开始执行程序中的指令。这些指令被解码并转换为机器指令，CPU 根据这些指令完成任务。

**运行时**：程序在运行时可能会进行各种操作，比如计算、调用库函数、处理输入/输出等。

**退出**：程序执行完毕或遇到错误时，会正常退出。退出时，操作系统会释放程序占用的资源，如内存和文件句柄。



# 进程和线程

+ 进程是资源分配和调度的最小单位，有独立的内存空间

+ 线程是进行运算调度的最小单位，共享进程的内存

+ js是单线程的， 但是可以开启多进程执行，比如webworker

# 进程

## 为什么需要多进程

+ 计算机有多核cpu， 适合处理多进程
+ 单进程的内存有上限， 多进程能够利用更多的内存
+ 充分利用计算机的资源，为了处理速度快

## 进程挂起和就绪状态的区别

**就绪状态**：

- **定义**：进程已加载到内存中，等待CPU分配时间片进行执行。
- **特点**：进程准备好运行，但尚未开始执行。

**挂起状态**：

- **定义**：进程由于某种原因被暂停，可能因为等待I/O操作、被外部中断、或者由于系统管理策略而挂起。
- **特点**：进程不在内存中运行，通常需要等待某些条件满足才能恢复到就绪状态。

## 进程之间通信

每个进程享有独立的内存空间， 进一步分为堆栈模型，进程之间需要特定方式合法通信， 比如微信是一个进程，微博也是一个进程，不能不经过进程通信就非法获取对方的数据

通信方式

+ 管道（Pipes）：允许一个进程的输出作为另一个进程的输入。包括匿名管道和命名管道。
+ 消息队列（Message Queues）：进程可以发送和接收消息，通过队列进行通信。
+ 共享内存（Shared Memory）：多个进程可以访问同一块内存区域，用于快速的数据交换
+ 信号量（Semaphores）：用于进程间的同步，控制对共享资源的访问
+ 套接字（Sockets）：用于网络进程或本地进程间的通信，支持不同机器间的数据交换。
+ 内存映射文件（Memory-Mapped Files）：允许进程将文件映射到内存中，通过内存操作文件内容，实现进程间通信。

## 进程什么时候会停止运行

**正常退出**：程序正常执行完所有指令并退出

**异常终止**：程序发生未处理的异常或错误，操作系统会终止进程。比如，访问了非法内存地址，或者除零错误。

**人为终止**：用户或系统管理员可以手动终止进程。例如，在Unix-like系统中，可以使用`kill`命令结束某个进程。

**资源限制**：进程可能因为超出系统资源限制（如内存、文件描述符等）而被操作系统终止。

**系统重启**：操作系统重启或关闭时，所有进程都会被终止。

## 进程调度算法

时间片轮转是操作系统中的一种进程调度算法，用于在多个进程之间公平地分配CPU时间

### 时间片轮转的实现

+ 定义时间片：时间片是一个固定的时间段，操作系统将其分配给每个进程。每个进程在时间片内运行，当时间片用完时，操作系统会中断该进程的执行，切换到下一个进程。

+ 调度队列：操作系统维护一个就绪队列（或循环队列），包含所有等待执行的进程。进程按顺序排列，准备进入CPU执行。

+ 上下文切换

  - **开始执行**：当CPU空闲时，调度程序从就绪队列中选择第一个进程，并将其加载到CPU中执行。

  - **时间片到期**：当时间片结束时，操作系统会暂停当前进程的执行，保存其当前状态（即上下文），并将其重新放入就绪队列的末尾。

  - **调度新进程**：操作系统从就绪队列中取出下一个进程，并将其加载到CPU中执行。

  - **保存和恢复状态**：上下文切换涉及保存和恢复进程的状态信息，包括寄存器内容、程序计数器等。这保证了每个进程在重新运行时能够从上次中断的地方继续执行。
  - **循环执行**：这个过程会不断重复，每个进程在其时间片内执行完后，被轮转到队列末尾，等待下一次调度

## node如何开启多进程

node开启多进程通信两种方式：child_process. fork和cluster.fork,  child_process更适合计算任务， cluster更适合进程守护

通过send和on传递消息

### child_process. fork方式开启多进程

```js
const http = require('http')
const { fork } = require('child_process').fork;

cosnt server = http.createServer((req, res)=>{
  if(req.url==='get-sum'){
    console.info('[log]主进程id', process.pid)
    // 开启子进程进程计算
    const childprocess = fork('./compute.js')
    // 给子进程发送计算通知
    childprocess.send('开始计算')
    childprocess.on('message', data=>{
      cosnole.info('[log]接收子进程的结果'，data)
      res.end(data)
    })
    childprocess.on('close',()=>{
      console.info('[log]子进程报错退出')
      childprocess.kill()
      res.end('error')
    })
  }
});
```

compute.js文件

```js
function getSum(){
  let sum =0;
  for(let i=0;i<10;i++){
    sum=sum+i
  }
  return sum
}

process.on('message', data=> {
  console.info('[log]接收到主进程发送的消息'， data)
  // 计算
  const sum = getSum()
  // 结果发送给主进程
  process.send(sum)
})
```

### cluster.fork开启多进程

可以用来做进程守护， 但是实际工作中一般使用pm2做进程守护

```js
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;  // 计算机有几核

if (cluster.isMaster) {
  console.log(`主进程 ${process.pid} is running`);

  // 开启子进程
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker) => {
    console.log(`子进程 ${worker.process.pid} died`);
    // 子进程错误而导致关闭，立刻开启另一个子进程==》进程守护保证稳定性
    cluster.fork();
  });
} else {
  // 子进程可以共享任何 TCP 连接
  // 在这种情况下，它是一个 HTTP 服务器，对用户无感知
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('hello world');
  }).listen(8000);
  console.log(`子进程 ${process.pid} started`);
}
```



# 操作系统的作用

管理和控制计算机系统硬件和软件资源

+ 管理系统资源：

  ```
  管理处理器（CPU）、内存、存储设备（硬盘、固态硬盘等）、输入/输出设备（键盘、鼠标、显示器、打印机等）等
  
  通过对资源的分配、调度和释放，操作系统确保系统的各项资源得到合理利用，提高系统的性能和效率。
  ```

+ 提供用户界面： 为用户和应用程序提供了与计算机系统进行交互的界面

+ 管理文件系统：管理计算机系统中的文件系统，负责文件的创建、删除、复制、移动、重命名等操作，以及文件的存储和访问权限控制

+ 提供系统服务： 提供了一系列系统服务和功能，如进程管理、内存管理、网络通信、安全性管理、设备驱动程序等，为应用程序提供必要的支持

+ 处理中断和错误： 操作系统能够处理硬件产生的中断信号和错误，以保证系统的稳定性和可靠性。它能够识别、记录和处理系统发生的各种异常情况，防止系统崩溃或数据丢失。

+ 实现多任务和多用户：操作系统支持多任务和多用户的并发执行，允许多个程序同时运行，并为每个用户提供独立的工作环境和资源访问权限。

+ 提供系统扩展和定制：允许用户根据需求对系统进行定制和配置，扩展系统的功能和性能。

## 如何实现内存管理

内存管理是操作系统的核心功能之一，主要通过以下方式实现：

+ 内存分配

  - **静态分配**：在程序编译时分配内存。

  - **动态分配**：程序运行时根据需求分配内存（如堆和栈的管理）。

+ **内存保护**：防止一个进程访问另一个进程的内存区域，确保进程间的隔离。
+ 虚拟内存：通过将内存空间映射到磁盘上的交换区（swap space），扩展可用内存。虚拟内存使得程序可以使用比物理内存更大的内存空间。
+ 分页（Paging）：将内存划分为固定大小的块（页），页面大小通常为4KB， 通过页表映射虚拟地址到物理地址。分页简化了内存管理并实现了虚拟内存。
+ **分段（Segmentation）**：将内存分为不同大小的段，每个段可以独立管理。分段根据程序的逻辑结构（如代码段、数据段）进行内存分配。分段使得程序的逻辑结构（如函数、数据结构等）能够映射到内存中，提供更直观的内存管理方式。可以更方便地进行段级保护和共享，控制不同段的访问权限。
+ 页面置换算法**：当物理内存不足时，选择将哪些页从内存移到磁盘中，常用算法包括最近最少使用（LRU）、最佳页面置换等。



# 内核态和用户态

## 内核态

+ 操作系统的特权级别较高的运行模式
+ 具有对系统硬件和资源的完全访问权限，可以执行进程调度、内存管理、设备驱动等

## 用户态

+ 操作系统的较低特权级别的运行模式
+ 程序在用户态中运行，只能访问自己的内存空间和被操作系统授予的一些资源， 无法直接访问系统硬件



# 进程和线程

## 进程

+ 是操作系统分配资源的基本单位，每个进程都有独立的内存空间，包含程序代码、数据和系统资源。
+ 进程之间相互独立，一个进程的崩溃通常不会影响其他进程。

## 线程

- 线程是进程内的执行单元，一个进程可以包含多个线程。线程共享相同的内存空间，可以访问相同的数据和资源。
- 多线程在同一进程内协同工作，共享进程的资源，但也可能因为共享资源而引发并发问题。

## **通讯方式**

+ **共享内存**

  ```
  进程或线程之间通过共享内存区域来进行通信。多个进程或线程可以访问相同的内存，通过读写共享内存来传递数据。
  优点是速度较快，缺点是需要进行同步和互斥，以防止多个进程或线程同时访问共享内存时发生冲突。
  ```

+ **消息传递**

  ```
  进程或线程通过发送和接收消息进行通信。
  优点是相对安全，因为进程或线程之间不共享内存，缺点是可能会引入一些开销。
  ```

+ **信号量**

  ```
  信号量是一种用于控制多个进程或线程对共享资源访问的同步机制。通过信号量，可以控制并发访问的数量。
  信号量常用于解决生产者-消费者问题等场景。
  ```

+ **管道（Pipe）：**

  ```
  - 管道是一种进程间通信的方式，通过一个进程的输出流连接到另一个进程的输入流。这样数据可以在两个进程之间传递。适用于具有父子进程关系的通信， 单向通信
  - 管道通常用于父子进程之间或者通过 fork 创建的进程之间。
  ```

+ **Socket：**

  ```
  - Socket 是一种进程间通信的网络通信方式，可以实现在不同计算机上的进程间通信
  - 通过套接字，进程可以通过网络传输数据，实现远程通信
  ```

# I/O

## I/O 操作是怎么实现的中断

I/O 操作涉及到设备（如硬盘、网络、键盘）与计算机之间的数据传输。

同步I/O：在同步I/O操作中，程序会等待I/O操作完成。这种方式简单但效率较低，因为CPU会被阻塞。

异步I/O：在异步I/O操作中，程序发起I/O请求后可以继续执行其他任务，而不需要等待I/O操作完成。这种方式利用了中断机制，提高了效率。

- **I/O请求**：当程序发起I/O请求时，设备驱动程序会将请求发送到设备控制器。
- **中断信号**：设备在完成I/O操作后，会向CPU发送中断信号。中断信号是一个通知，告知CPU有事件需要处理。
- **中断处理**：CPU 接收到中断信号后，会暂停当前的执行，保存当前状态，然后跳转到中断处理程序。中断处理程序会处理设备发来的数据或执行其他必要的操作。
- **恢复执行**：中断处理完成后，CPU 会恢复到之前的状态，继续执行原来的程序。

这种中断机制允许CPU在等待I/O操作时去执行其他任务，从而提高系统的整体效率。