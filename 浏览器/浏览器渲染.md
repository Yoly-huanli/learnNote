[toc]

# 1.浏览器渲染原理

js下载==》解析为style==》cssDOM/DOM==》renderDOM==》布局layout==》绘制==》复合

执行js有js引擎，渲染有渲染引擎，比如IE是Trident,Firfox是Gecko,Chrome,Safari和Opera现在是Blink(之前是webkit),了解渲染原理主要为了提升性能

```
html,css,js在网络中是0，1这样的字节数据传输的，浏览器接收之后先把字节转换为字符串，再词法分析
```

- html:词法分析后转换为节点，再按照节点之间的关系转换为DOM节点数
- css:生成CSSOM树，确定样式对应的节点，这里还涉及到了样式的继承，而且应该尽量避免太过具体的标签，比如 div p span 就需要先遍历得到所有div节点，再找到全部p节点，再找到它其下的span标签
- 生成渲染树：DOM树与CSSOM树进行合并（只是可见节点的节点与样式合并，display:none的节点不会渲染）
- 布局render树（Layout/reﬂow），负责各元素尺寸、位置的计算(盒模型)
- 绘制：绘制页面像素信息
- 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕

## DOM树生成过程

"浏览器是多进程架构，而其中有一个渲染进程，负责页面的渲染和js脚本的执行，而在渲染进程中有有一个网络进程, 一个HTML解析器，网络进程负责根据content-type创建渲染进程，然后渲染进程将它解析为dom"

- Bytes
- 变为一个个的单词
- 找到标签与闭合标签
- 生成DOM节点
- 生成DOM树

## 渲染树

 一般是DOM树和CSSDOM树合并，但是比如title，display:none的不显示在渲染树

## 什么情况阻塞渲染

- html和css:减少文件的大小，css优化选择器
- script:遇到script标签会先去解析script标签内容，因此把它放在body底部，而async和defer会异步加载不会阻塞html转换

# 2.重绘与回流

- 回流：布局和尺寸发生变化会导致回流
- 重绘：不改变布局与尺寸，只有外观发生改变，比如只改变颜色的时候
- 回流必会导致重绘，重绘不一定会导致回流

## 什么情况会导致回流

- 页面渲染初始化
- DOM结构改变，比如删除/新增了某个节点,移动了某个节点
- render树变化，比如减少了padding，display:none
- 窗口resize
- 改变字体大小会引发回流
- 复杂的一种：获取某些属性，引发回流 当获取 一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括：

```
1. oﬀset(Top/Left/Width/Height) 
2. scroll(Top/Left/Width/Height) 
3. cilent(Top/Left/Width/Height) 
4. width,height 
5. 调用了getComputedStyle()或者IE的currentStyle
```

**优化，减少回流与重绘**

- 一次性更改style，或者将样式定义为class并一次性更新
- 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到 window.document
- 避免多次读取oﬀset等属性。无法避免则将它们缓存到变量，最好获取一次，再在这个基础上修改
- 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高
- 将频繁重回回流的元素设置为图层，比如vedio,iframe是自动被设置为图层的（绘制） **简单层与复合层（绘制）**
- 可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的
- 如果开启了硬件加速功能，可以将某个节点变成复合图层，复合图层之间的绘制互不干扰，由GPU直接控制
- 简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的
- 因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速
- 需要对DOM元素进行复杂的操作时，可以先隐藏（display：none），操作完成后再显示
- 避免使用table布局，因为table元素一旦触发回流就会导致table里所有的其他元素回流

**资源外链的下载** CSS样式资源 JS脚本资源 img图片类资源

**CSS资源外链**

- 当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个 http请求，对应一个tcp/ip链接）。
- CSS下载时异步，不会阻塞浏览器构建DOM树 但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行

**JS资源外链**

- 发现一个JS外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML
- 在脚本阻塞时，也会继续下载其它资源，但是解析仍然被阻塞
- 加defer与async属性， defer是延迟执行，而async是异步执行。

**遇到img图片类资源** 直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方。

### 为什么操作DOM很慢，如何新增上万个DOM
+ 原因：DOM是渲染引擎，JS是JS引擎，用JS操作DOM会导致两个线程之间的不断通信，且还有回流和重绘的问题
+ 解决方法
+ 1.虚拟列表：只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。
react-virtualized基础组件的使用

### CSS性能使得JS变慢
UI线程和JS线程是互斥的，因为JS可能需要获取渲染完成后页面的某些样式属性。如果有频繁的重绘回流，会导致JS变慢。