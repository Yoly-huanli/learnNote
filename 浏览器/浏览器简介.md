[toc]

# 浏览器内核

最初内核的概念包括渲染引擎与JS引擎，目前习惯直接称渲染引擎为内核，JS引擎独立。比如：chrome浏览器使用blink内核，V8JS引擎。

+ 渲染引擎（浏览器内核）：主要功能是解析HTML/CSS进行渲染页面，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。
+ JS引擎: 专门处理JavaScript脚本的虚拟机、解释器，用来解释执行js代码。

主要浏览器内核

```
Chrome   webkit->blink
Firefox   Gecko
safari    webkit
Opera   Presto->blink
```

主要js引擎

```
Chrome     V8
Firefox    SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）
Safari     Nitro（4-）
Opera Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-）
IE -> Edge    JScript（IE3.0-IE8.0 / Chakra（IE9+之后）

```

# v8引擎

js是解释型语言，所以它无需提前编译，而是由解释器实时运行

## 引擎对JS的处理原理

即时编译器将源码编译成机器码运行

+ 读取代码，进行词法分析，然后将代码分解成词元（token）

![image-20220628103340863](../img/image-20220628103340863.png)

+ 对词元进行语法分析，然后将代码整理成抽象语法树(AST)

![image-20220628103505209](../img/image-20220628103505209.png)

+ 使用翻译器（translator），将代码转为字节码（bytecode）

- 使用字节码解释器（bytecode interpreter），将字节码转为机器码

最终计算机执行的就是机器码。为了提高运行速度，，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）

### JS的预处理阶段

在正式执行JS前，还会有一个预处理阶段

- 分号补全,如果不写分号在代码压缩为一行的时候可能会导致出错

```
function buquan(){
    return
    {
        'a':'a'
    }
}
//分号补全
function buquan(){
    return;
    {
        'a':'a'
    };
}
//结果为undefined
```

- 变量提升，在代码执行前先进行解析

```js
var a=9;
console.log(a)
var class='12'
```

```js
function fn(){
//var web 变量提升，在这里声明了，if语句还是起了作用
   if(false){
     var web='hh' 
   }
console.log(web)//undefined
}
```

### JS的执行阶段

- 1.执行上下文

```
JS有执行上下文
1.浏览器首次载入脚本，它将创建全局执行上下文，并压入执行栈栈顶（不可被弹出）
2.然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部
3.一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。
这样依次执行（最终都会回到全局执行上下文）
```

每一个执行上下文，都有三个重要属性:

```
+ 变量对象(Variable object ， VO)
+ 作用域链(Scopechain)
+ this
```

- 2.VO（变量对象）和AO（活动对象）

```
VO中会存放一些变量信息（如声明的变量，函数， arguments参数等等
AO（ activationobject)，当函数被调用者激活，AO就被创建了。
```

- 3.作用域链
- 4.this this是执行上下文环境的一个属性，而不是某个变量对象的属性

### a.b.c.d 和 a['b']['c']['d']，哪个性能更高？

a.b.c.d 比 a['b']['c']['d'] 性能高点，后者还要考虑 [ ] 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。