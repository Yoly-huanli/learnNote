[toc]

# package.json与package-lock.json

+ 在npm5之前没有package-lock.json文件，package.json只能锁定模块的大版本号（版本号的第一位），不能锁定后面的小版本，所以每次重新npm install时候拉取的都是该大版本下面最新的版本，而且也不会去去记录具体的每个包的依赖

+ package-lock.json是在运行“npm install”时生成的一个文件，用于记录当前状态下项目中实际安装的各个package的版本号、模块下载地址、及这个模块又依赖了哪些依赖。

  > 附： npm v2是递归安装，将每个模块的依赖安装到自身的node_modules文件夹中，形成一个**高度嵌套**的依赖树
  >
  > npm v3是扁平化的依赖结构， 为了生成扁平化的依赖树，npm需要遍历项目中的所有依赖关系，构建完整的依赖关系树，这是一个比较耗时的操作
  >
  > npm v5 package-lock.json文件， 锁定项目的依赖结构

# 如何调试npm包

项目中使用了某个npm包，但是想对npm包进行调试

+ 下载npm包到本地项目
+ 在npm对应的本地项目 npm link
+ 在引用了该npm包的项目输入 npm link XXX（package.json里该npm包的名）
+ 此时在本地npm包修改内容可以直接反映在引用了该npm包的项目里

# Npm其他用法

可以使用nrm工具进行管理仓库

# pnpm,npm,yarn不同

+ 依赖解析和版本锁定：
  + pm 在 `package.json` 文件中使用 `package-lock.json`来锁定依赖版本，确保在不同的环境中安装相同的版本。
  + Yarn 使用 `yarn.lock` 文件来锁定依赖版本。它引入了离线模式，允许在没有互联网连接时使用本地缓存进行安装。
  + pnpm 使用单个 `pnpm-lock.yaml` 文件来锁定依赖版本，类似于 `yarn.lock`。与 npm 和 yarn 不同，pnpm 在一个全局的 `node_modules` 目录中共享依赖项。
+  **性能和磁盘空间**
  + npm和yarn的依赖锁定文件只是避免了某个项目的安装重复， 但是pnpm可以避免项目与项目之间的重复，因为它把所有的文件都保存在硬盘资源里，通过硬链接，共享硬盘资源，提高安装速度

## npm和yarn 为啥会有<font color="red">幻影依赖</font>的问题

+ 幻影依赖：未在项目 `package.json` 中声明的依赖，但在项目中依然可以意外的被正确引用。

  ```
  因为是扁平化管理依赖，项目里其他插件内部有引用
  ```

+ npm和yarn最大可能复用文件包或者维护同一个磁盘镜像吗

  ```
  yarn2 的话有一个 pnp 的模式就是维护同一个磁盘镜像的包，并且提供了对特定依赖包更改调试的方法，但是这种模式过于激进，直接取消了node_modules ，这样会产生一系列兼容性问题
  ```

+ 假如 `pnpm` 依赖了一个 `npm` 包，这个 `npm` 包会有幻影依赖的问题吗（默认的话）

  ```
  默认的话还是存在幻影依赖的问题的，因为 pnpm 的配置中默认有一个参数hoist: true ,默认是会提升子依赖的。
  ```

## pnpm为什么安装速度快

+ 并行安装
+ **链接依赖项：** pnpm 通过将项目中的依赖项链接到全局存储库中的单个实例，而不是像 npm 和 yarn 那样将每个依赖项复制到项目的 `node_modules` 目录中。这样做可以大大减少磁盘占用和文件复制的时间。
+ **快磁盘缓存：** pnpm 使用了一种称为“快磁盘缓存”（fast disk-caching）的机制。它会在全局存储库中缓存已经下载过的包，当需要用到相同的包时，直接从缓存中拷贝，而不需要重新下载。

# 软链接和硬链接的区别

+ 硬链接（Hard links）：可以这样理解，硬链接就是某个文件实体的别名。硬链接甚至可以使多个文件名拥有相同的inode，你可以为单个文件创建多个硬链接。在不同的文件系统中，inode可能产生冲突，所以不能为不同文件系统或分区的目录和文件创建硬链接。
+ 软链接（Soft links, Symbolic links）：就像在Windows系统中创建快捷方式一样，创建软链接实际上相当于创建一个指向某个文件实体指针变量，可以为不同文件系统或分区的目录创建软链接。
