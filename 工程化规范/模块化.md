参考：

https://segmentfault.com/a/1190000017466120

[toc]

## 1.模块化

简单理解：就是把一些复杂的功能做成独立的模块进行管理，然后应用于不同的项目、场景下，避免重复开发，对于使用该模块的使用者来说，模块相当于一个接口，使用这个接口实现自己需要的功能即可，不需要关心它内部具体的实现

## 2.模块化实现方式

### （1）全局函数模式

将要实现的功能写在其他js文件里，直接暴露出来

```js
<script type="text/javascript" src="module1.js"></script>
<script type="text/javascript" src="module2.js"></script>
<script type="text/javascript">
  foo()
</script>
```

这里引入了两个模块，它们内部分别为

```js
//module1
function foo() {
  console.log('module1')
}
//module2
function foo() {
  console.log('module2')
}
```

结果：最终打印结果为module2,可以看到这里有两个问题

+ 命名冲突时，后引入的模块会覆盖上一个模块的同名函数
+ 污染了全局变量，对于引入模块的index.html，如果再写一个函数function foo()，则会覆盖module里的foo(),所以映入模块后，在当前文件里是最好不要再去使用foo()的

### （2）命名函数模式

将要暴露的方法通过简单的对象进行封装

```js
<script type="text/javascript" src="module1.js"></script>
<script type="text/javascript" src="module2.js"></script>
<script type="text/javascript">
  module1.foo()
  module2.foo()
 
  module1.data = 'hello' 
  module1.foo()
</script>
```

这里同样引入了另两个模块

```js
//module1
let module1 = {
  data: 'module1',
  foo() {
    console.log(`foo() ${this.data}`)
  },
}
//module2
let module2 = {
  data: 'module2',
  foo() {
    console.log(`foo() ${this.data}`)
  }
}
```

执行结果，分别输出了module1和module2，解决了上述的命名冲突问题，但是存在的问题是数据不安全，可以在当前引入该模块的页面直接修改模块内的内容

### （3）匿名函数模式

将所有逻辑写在自动执行函数内, 通过给window添加属性来向外暴露接口，这样内部变量是私有的，只能使用暴露出来的方法

```js
<script type="text/javascript" src="module1.js"></script>
<script type="text/javascript">
      myModule.foo()
      console.log(myModule.data) 
      myModule.data = 'xxxx' 
      myModule.foo() 
</script>
```

```js
//module1.js
;(function(window) {
  let data = 'foo'
  function foo() {
    console.log(`foo() ${data}`)
  }
  window.myModule = { foo }
})(window)
```

结果为foo,undefined,foo

==>问题：模块内部如何引用其他模块

#### 引入其他模块

方法：与window一样传入即可，但是要保证传入之前已经存在该被引入的模块,比如模块中想使用jquery

```js
<script type="text/javascript" src="jquery-1.10.1.js"></script>
    <script type="text/javascript" src="module4.js"></script>
    <script type="text/javascript">
      myModule.foo()
</script>
```

```js
;(function(window, $) {
  //数据
  let data = 'FOO'
  function foo() {
    //用于暴露有函数
    console.log(`foo() ${data}`)
    $('body').css('background', 'red')
  }
  window.myModule = { foo}
})(window, jQuery)
```

其实jquery本身内部实现也是采用的匿名函数的方式

```js
(function( window, undefined ) {
...
    //模块方式导出
    if ( typeof module === "object" && module && typeof module.exports === "object" ) {
      module.exports = jQuery;
    } else {
      //全局方式导出
      window.jQuery = window.$ = jQuery;
      //匿名的AMD模块方式
      if ( typeof define === "function" && define.amd ) {
        define( "jquery", [], function () { return jQuery; } );
      }
})( window );
```

存在问题：模块之间的依赖关系不清楚，先引入哪个再引入哪个

## 3.规范化的模块

### (1)common.js

这个规范服务端与浏览器端都可以用，服务器端是运行时加载，而在浏览器中使用时，需要提前打包编译好

#### 在服务器端

```js
node install
node app.js
```

在文件app.js中

```js
//引用模块
let module2 = require('./modules/module2')
let module1 = require('./modules/module1')

let uniq = require('uniq')

//使用模块
module1.foo()
module2.foo()

console.log(uniq([1, 1, 1, 2]))
```

module中

```js
//module1
module.exports = {
  foo() {
    console.log('moudle1 foo()')
  }
}
//module2
module.exports = {
  foo() {
    console.log('moudle2 foo()')
  }
}
```

执行结果

```js
module.exports = {
  foo() {
    console.log('moudle1 foo()')
  }
}
```

##### 补充说明：

+ 每个模块都有自己的作用域，不会造成全局污染
+ 在运行时才进行加载，所以模块运行的顺序就是加载的顺序，而不是受引入顺序的影响
+ 第一次加载后模块会缓存，之后再次使用该模块，使用的是缓存中的方法

##### 模块引入（require）

require的作用是读入对应模块，并且返回该模块的export对象

+ 自定义的模块，按照路径引入
+ 对于第三方模块，需要npm引入，然后按照模块的名称进行引入使用

```
npm install uniq --save
```

##### 暴露模块（module/exports）

module代表模块本身，exports是module上的一个对象,可以对外暴露方法

+ module.exports=对象

```js
module.exports = {
  foo () {
    console.log('moudle2 foo()')
  }
}
...
let module1 = require('./modules/module1')
module1.foo()
```

+ module.exports=函数

```js
module.exports = function () {
  console.log('module1()')
}
...
let module1 = require('./modules/module1')
module1()
```

+ module.exports.x=函数

```js
exports.foo = function () {
  console.log('module1 foo()')
}
...
let module1 = require('./modules/module1')
module1.foo()
```

#### 在浏览器端

在浏览器端使用CMD标准下的模块，需要提前进行代码的打包和编译，才能进行使用，比如使用browserify

```js
//安装browserify
npm install browserify -g
//打包browserify
browserify app.js -o dist/bundle.js
```

其中app.js里内容

```js
let module1 = require('./modules/module1'
module1.foo()
```

module1的内容

```js
exports.foo = function () {
  console.log('module1 foo()')
}
```

新建index.html引用打包好后的文件

```js
<script type="text/javascript" src="./dist/bundle.js"></script>
```

此时，浏览器的控制台执行了app.js并且打印出module1 foo()

### （2）AMD（require.js）

浏览器端需要从服务器下载模块，所以像commonjs一样执行时才同步加载是不合理的，应该提前加载好，然后再去使用

#### 之前没有使用规范

服务器端没有使用AMD，而是已经比较完善的匿名函数模式，存在的问题是模块之间的依赖关系不清晰，引入的顺序不确定，而且引入几个模块，就需要发起几个请求。

#### AMD规范使用



基本使用步骤：

+ require.js下载，并把require文件放在js目录下

```
官网https://requirejs.org/docs/release/2.3.6/r.js下载require.js
```

+ 新建index.js,引入require.js并设置主文件入口

```js
 <script data-main="./js/main.js" src="./js/require.js"></script>
</body>
```

+ Main.js里引入模块，并且写逻辑，使用模块的时候用require的方式

```js
(function () {
  require.config({
    baseUrl: 'js/',
    paths: {
      module1: './module1',
      module2: './module2'
    }
  })
  require(['module2'], function (module2) {
    module2.showMsg()
  })
})()
```

+ module2的内容:定义模块使用的define，这里依赖了module1,并且暴露出方法showMsg

```js
define(['module1'], function (module1) {
  let name = 'yoly'
  function showMsg () {
    alert(module1.getMsg() + ', ' + name)
  }
  return { showMsg }
})
```

+ module1的内容,没有依赖其他模块

```js
define(function () {
  let msg = 'hello'
  function getMsg () {
    return msg
  }
  return { getMsg }
})
```

### (3)CMD(sea.js)

也是用于浏览器端，但是它整合了require.js和common.js规范，不用将依赖的模块显示放在define里

+ 下载sea.js

```
下载sea.js
```

+ index中引入sea.js

```js
<script type="text/javascript" src="./js/sea.js"></script>
  <script type="text/javascript">
    seajs.use('./js/main')
  </script>
```

+ 主模块中引入调用的模块module1与module2,主模块main.js

```js
define(function (require) {
  var module1 = require('./module1')
 require.async('./module2', function (module2) {
   console.log('异步引入依赖模块2  ' + module2.msg)
  })
  module1.show()
})
```

+ module1为同步引入，module2为异步引入

```js
//module1
define(function (require, exports, module) {
  var data = 'module1'
  function show () {
    console.log('module1 show() ' + data)
  }
  exports.show = show
})
```

```js
//module2
define(function (require, exports, module) {
  module.exports = {
    msg: 'module2'
  }
})
```

### (4)UMD

通用模块定义，用if作判断，兼容commonJS与AMD

### (5)ES6模块化

CommonJS 和 AMD 模块，都只能在运行时才能确定模块之间的依赖关系，而ES6则在编译时就能确认， 因此可以提前对类型等进行校验，而且自动采用严格模式（顶层的this返回undefined）使用方法如下：

+ 安装ES6到ES5转换工具

```
npm config set registry http://registry.npm.taobao.org/
npm install babel-cli browserify -g
npm install babel-preset-es2015 --save-dev
```

+ js文件夹下新建文件module1.js并暴露出模块方法,在main.js引入模块module1

```js
//module1
export function foo () {
  console.log('foo() module1')
}
export function bar () {
  console.log('bar() module1')
}
//main.js
import { foo, bar } from './module1'
foo()
bar()
```

+ 配置.babelrc.js

```js
  {
    "presets": ["es2015"]
  }
```

+ 将目标文件夹下模块编译为es5语法，保存在dist目录下

```js
 babel js  -d dist  
```

+ 使用Browserify编译打包

```js
 browserify dist/main.js -o dist/bundle.js 
```

+ 在index.html使用打包后的文件

```js
  <script type="text/javascript" src="./dist/bundle.js"></script>
```

如果浏览器已经原生支持ES6，那么可以直接原生加载

```js
<script type="module">
    import './module1'
</script>

<script type="module" src="./module1"></script>
```

type="module"会被认为是模块

#### 特性

+ 默认严格模式，顶级模块this为undefined，而不是window，var声明也不会挂载到wndow
+ ES6模块异步加载与执行，只能加载后执行
+ 模块只能加载一次

#### 引入与导出方法

```js
**引入导出方法及区别**

export default XXX 
import XXX from './a.js' 
等效于
import {default as XXX} from './a.js'

export {XXX}
import { XXX } from './a.js' 
import * as mod1 from './a.js'
```

+ export default XXX，是值的引用，当a.js里发生改变时，引用的文件里不会立即改变，export {XXX},当a.js里发生改变时，引用的文件里立即改变
+ import会被提高到模块顶部，因此使用import的位置不重要，但是推荐放在顶部
+ 路径不能是拼接的字符串

## 对比

- CMD 推崇依赖就近(要用的时候才require引入)，AMD 推崇依赖前置(一开始就把所有用到的模块引入)。
- AMD 是将需要使用的模块先都加载完再执行代码，而 CMD 是在 require 的时候才去加载模块文件，加载完再接着执行
- CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMD规范则是非同步加载模块，允许指定回调函数。

```
CommonJS在引入时是加载整个模块，生成一个对象，然后再从这个生成的对象上读取方法和属性。一旦输出之后，无论模块内部怎么变化，都无法影响之前的引用。
ESModule 不是对象，而是通过export暴露出要输出的代码块，在遇到import后生成一个引用链接，在脚本真正执行时才会根据这个引用链接去模块里面取值，模块内部的原始值变了import加载的模块也会变。而不是直接加载整个模块。
```

![image-20220123224457922](/Users/didi/Library/Application Support/typora-user-images/image-20220123224457922.png)
