[toc]

## 为什么要缩短js解析时间

为什么？

+ js需要进行加载、解析&编译、执行，开销最大，相同大小的图片资源和js资源，js的开销更大
+ js的加载过程可能会造成阻塞，此时即使用户看到了页面，但是却无法进行交互。

## 1.代码层面上进行优化

- 外部第三方的JS文件：
  - Code splitting 代码拆分，按需加载
  - Tree shaking 代码减重 （比如lodash，不需要其全部的功能函数）
- 减少主线程工作量：
  - 避免长任务（任务越长、阻塞时间越久）
  - 避免超过1KB的行间脚本
  - 使用rAF和rIC进行时间调度

## 2.利用V8进行优化

代码==》解析为抽象语法树==》抽象为字节码==》机器码

这个过程V8会自动进行一部分优化工作

利用V8的优化机制：

- 脚本流：脚本正常情况是先下载，再解析，V8优化当脚本下载够30KB，就单独开一个线程解析，一边下载一边解析
- 字节码缓存，多个页面可能使用了相同的逻辑，会被解析为相同的字节码，所以会把字节码缓存起来
- 懒解析：只有当函数真正被调用的时候，才会去解析函数体，如果没有调用，就不会进行解析。这样的解析方式会对性能有很好的提升。
- 比如对于函数的输入参数，最好每次传入的参数类型相同（比如每次都传入数字，避免传入字符串等其他类型）

## 3.函数优化

+ V8这样的JS引擎，默认对函数进行**懒解析（lazy parsing）**
+ 实际开发中有的情况需要JS立即去执行，此时如果是懒解析的函数但是发现需要立即执行，于是又快速的进行了一个**饥饿解析（eager parsing）**，这样的话会先进行了一次饥饿解析，然后又进行了一次懒解析，执行效率反而降低了。

+ 那么如何告诉解析器某个函数需要立即解析:

只需加一对括号：

```
const add = ((a,b) => a+b)    // 这样的作用是告诉解析器，当看到这个函数的时候就对这个函数进行解析
const n1 = 1
const n2 = 2
add(n1,n2)
```

 这样当后面需要调用的时候就可以直接调用了

有个问题：

- 当把代码进行压缩时（uglyfy），可能会把这对括号去掉
- 解决：Optimize.js可以在压缩以后把括号加回来
  - uglyfy后来把这些问题也解决了，需要兼顾老版本的可以添加

## 4.对象优化

js是一个弱类型的语言，在声明的时候不会声明这个变量的类型。但是对于编译器而言，还是需要一个具体的类型。如何做：v8在解析的时候会给这个变量进行推断，赋一个具体的类型（隐藏类型HC，隐藏类型会有顺序）

对象优化可以做的事：

- 以相同顺序初始化对象成员，这样初始化时候的隐藏类型可以复用

![image-20221011202652871](../img/image-20221011202652871.png)

- 实例化后避免添加新属性，因为查询新属性需要间接查询

  ![image-20221011202909904](../img/image-20221011202909904.png)

- 尽量使用Array代替array-like对象（如argument）

  ```json
  //array-like 只是有length等类似数组的属性，但是没有数组本身的一些方法，比如forEach等
  可以先把类数组转换为数组，再调用数组原生的方法
  Array.prototype.slice.call(arraylike, 0)
  ```

- 避免读取超过数组的长度
  - 会造成沿原型链的查找，会增加开销（据统计会相差六倍）
- 避免元素类型转换，如[1,2,3]push了一个1.2的元素，数组默认的类型会被更改
  - 即类型给的越具体，编译器能做的优化越多
  - 越通用，能做的优化越少

## 5.HTML的优化

HTML的大小占比较小，可以做的优化也小，但是也能做：

- 减少iframes的使用。iframes会阻塞父文档的加载。要用的话可以使用延迟加载，不影响初始时页面加载。
- 压缩空白符，空行，删除注释
- 避免节点深层级嵌套，dom树占用内存更多，并且遍历更耗时，常见的是div的无效嵌套
- 避免使用table布局
- CSS&JS尽量外链，不要写在行间
- 删除元素默认属性，不用添加多余的字符，造成多余的传输

借助工具：

- html-minifier
- ...

## 6.CSS的优化

- 降低CSS对渲染的阻塞　　

  - 对目前用不到的CSS，可以延迟加载

- 利用GPU进行完成动画(transform和opacity优化)

- 使用[contain](https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain)属性进行布局

  ```
  CSS** contain** 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图、大小或这四项的组合时，只影响到有限的 DOM 区域，而不是整个页面，可以有效改善性能。
  contain: layout; //表示元素外部无法影响元素内部的布局，反之亦然。
  contain:size
  表示这个元素的尺寸计算不依赖于它的子孙元素的尺寸。
  xxx
  ```

- 使用font-display属性,使得文字更早进行显示，并且减少文字闪烁