[toc]

# 路由模式实现原理

监听url的变化

## hash模式

location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。

通过hashchange事件监听，感知页面变化，达到“更新视图但是不重新发起请求”的要求，但是不美观

```js
window.addEventListener("hashchange", funcRef, false); 
```

## history模式

主要使用HTML5 新推出的功能， history.pushState 和 history.replaceState 改变 URL

这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。

 History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，可能出现404（刷新）， 所以项目后端可以在nginx里进行路由配置，没有路径对应的资源的时候，默认加载index.html



两种模式对比

+ Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL
+  History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串
+ Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 1index.html 页面用于匹配不到静态资源的时候

# 动态路由

 类似{ path: "/user/:id", component: **User** }



# 路由钩子函数

路由钩子的执行流程, 钩子函数种类有:全局守卫、路由守卫、组件守卫

**完整的导航解析流程:**

+ 导航被触发
+ 在失活的组件里调用 beforeRouteLeave 守卫。
+ 调用全局的 beforeEach 守卫。
+ 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
+ 在路由配置里调用 beforeEnter。
+ 解析异步路由组件。
+ 在被激活的组件里调用 beforeRouteEnter。
+ 调用全局的 beforeResolve 守卫 (2.5+)。
+ 导航被确认。
+ 调用全局的 afterEach 钩子。
+ 触发 DOM 更新。
+ 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

