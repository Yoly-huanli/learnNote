## vue.$set

vue.$set(target,key,value),这是由于 Vue 会在初始化实例时进行双向数据绑定，使用Object.defineProperty()对属性遍历添加 getter/setter 方法，所以属性必须在 data 对象上存在时才能进行上述过程 ，这样才能让它是响应的。如果要给对象添加新的属性，此时新属性没有进行过上述过程，不是响应式的，所以会出现数据变化，页面不变的情况，此时需要用到$set，但是这个api的参数key是一个String|Number,如果传入一个‘key1.key2.key3’，是不会进行深层的绑定的，只会把‘key1.key2.key3’作为一个整体的key。

## .props和mounted谁先执行

props总结
获取不到props的原因: 因为父组件中要传递给子组件的 props 属性 是通过 ajax请求获取的， 请求的这个过程是需要时间的异步获取等待返回，然而子组件的渲染要快于ajax请求过程，所以此时在**created** 、 **mounted** 只执行一次的生命钩子函数中，执行完成后，此时 props 还没有传递（子组件），所以只能获取默认的props值，当props获取ajax完成后传递进来，此时生命周期函数已经执行完成。所以**wacth**监听数据变化来解决问题。

## Vue Demi

Vue Demi是一个让你可以开发同时支持Vue2和3的通用的Vue库的开发工具，而无需担心用户安装的版本。

# 运行时

`You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.`意思就是说 ，您使用的是仅运行时版本的Vue，这种情况下，模板编译器是不可用的，可以将模板预编译为呈现函数，也可以使用编译器包含的内部版本。

## 加载图片

需要用require

# provider

可以在new vue的时候就注入

```js
new Vue({
  el: '#app',
  provide() {
   return { locale: locale }
  },
  render: h => h(App)
 })
```

# 下载链接无法下载

```js
https下无法下载http的资源
需要改用https
```

## npm 安装冲突

unable to resolve dependency tree

无法解析依赖树

```
npm i --legacy-peer-deps
该命令是解决因npm版本不兼容产生的一系列问题
```



## vue3获取this

使用Vue3 setup方法时碰到一个很有意思的用法-getCurrentInstance. setup是在生命周期beforeCreate和created之前执行，此时vue对象还没有创建，因此无法使用vue2中的this. 但是getCurrentInstance方法却能帮助我们较好的解决这个问题，getCurrentInstance可以获取当前组件的实例、上下文，使用getCurrentInstance会返回ctx和proxy，和vue2.x中的this等同。用法如下：

```
import { getCurrentInstance } from 'vue'
2//获取当前组件实例
3 const instance = getCurrentInstance ();
41/获取当前组件的上下文，下面两种方式都能获取到组件的上下文。
5const{ctxj=getcurrentInstance0;//方式一,这种方式只能在开发环境下使用，生产环境下的ctx将访问不到
6const{proxy}=getCurrentInstance()；1/方式二，此方法在开发环境以及生产环境下都能放到组件上下文对象（(推荐）
711ctx中包含了组件中由ref和reactive创建的响应式数据对象，以及以下对象及方法;
8 proxy.$attrs
9 proxy.$data
10 proxy.$el
11 proxy.$emit
12 proxy.$forceUpdate
13 proxy. $nextTick
14 proxy. soptions
15 proxy.$parent
16 proxy.$props
17 proxy.$refs
18 proxy.$root
19 proxy.$slots
20 proxy.$watch
```

## props的数据

+ 不能直接改变props进来的值

+ 不能把props的值直接放到v-model里，但是可以使用另一个变量的get和set

  ```vue
  <template>
    <input
      v-model="internalVal"
      @input="change"
    />
  </template>
  
  <script>
  export default {
    name: 'index',
    props: {
      value: { 
        type: String,
        default: ''
      }
    },
    methods: {
      change(value) {
        this.$emit('change', value)
      }
    }
    computed: {
      internalVal: {
        get () {
          return this.value
        }
      }
    }
  }
  </script>
  ```

  
