## vue.$set

vue.$set(target,key,value),这是由于 Vue 会在初始化实例时进行双向数据绑定，使用Object.defineProperty()对属性遍历添加 getter/setter 方法，所以属性必须在 data 对象上存在时才能进行上述过程 ，这样才能让它是响应的。如果要给对象添加新的属性，此时新属性没有进行过上述过程，不是响应式的，所以会出现数据变化，页面不变的情况，此时需要用到$set，但是这个api的参数key是一个String|Number,如果传入一个‘key1.key2.key3’，是不会进行深层的绑定的，只会把‘key1.key2.key3’作为一个整体的key。

## .props和mounted谁先执行

props总结
获取不到props的原因: 因为父组件中要传递给子组件的 props 属性 是通过 ajax请求获取的， 请求的这个过程是需要时间的异步获取等待返回，然而子组件的渲染要快于ajax请求过程，所以此时在**created** 、 **mounted** 只执行一次的生命钩子函数中，执行完成后，此时 props 还没有传递（子组件），所以只能获取默认的props值，当props获取ajax完成后传递进来，此时生命周期函数已经执行完成。所以**wacth**监听数据变化来解决问题。

## Vue Demi

Vue Demi是一个让你可以开发同时支持Vue2和3的通用的Vue库的开发工具，而无需担心用户安装的版本。

# 运行时

`You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.`意思就是说 ，您使用的是仅运行时版本的Vue，这种情况下，模板编译器是不可用的，可以将模板预编译为呈现函数，也可以使用编译器包含的内部版本。



## 加载图片

需要用require
