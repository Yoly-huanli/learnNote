[TOC]

## keep-alive组件的用法

https://www.jianshu.com/p/480c52580c8a

```xml
（1）一般keep-alive组件和<router-view>结合使用：
<keep-alive>
     <router-view></router-view>
</keep-alive>
（2）keep-alive也可以和一些动态组件结合使用：
<keep-alive>
  <component :is="view"></component>
</keep-alive>

作用：<keep-alive> 包裹动态组件或者router-view时，会缓存不活动的组件实例，而不是销毁它们，
也就是被<keep-alive>包裹的组件，当加载之后，再次被加载时不会重新渲染，而是使用离开这个组件时保留的缓存；
```

参数

```js
include:可以指定包裹在keep-alive中的组件允许被缓存；
exclude:可以指定包裹在keep-alive中的组件不允许被缓存；
max:最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。
```

### （1）缓存了子组件的什么东西

+ 缓存了**子组件的 Vue 实例**和子组件上次渲染的真实DOM

### （2）keep-alive如何缓存子组件

在 keep-alive 组件的 Vue 实例中有一个 cache 属性，该属性是一个对象，这个对象用来缓存子组件的 vnode，vnode 有个 componentInstance 属性，这个 componentInstance 属性就是缓存的 Vue 实例，在 componentInstance 属性中有个 $el 属性，这个 $el 属性是缓存的真实 DOM。

## 抽象组件

```js
export default {
  name: 'keep-alive',
  abstract: true,
```

抽象组件没有真实的节点，抽象组件不会渲染成 DOM 元素，也不会出现在父组件链中，而只是作为中间的数据过度层处理，在keep-alive中是对组件缓存做处理

## 接收的参数

```js
props: { //接收三个参数,
    include: patternTypes, //缓存白名单，允许缓存
    exclude: patternTypes, //缓存黑名单，不允许缓存
    max: [String, Number]  //缓存的最大实例数量
}
```

## 缓存初始化与卸载

```js
created () {
  this.cache = Object.create(null) //缓存的组件
  this.keys = [] //缓存组件的key数组
},

  destroyed () {
    for (const key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys) //删除缓存中所有vnode
    }
  },
```

删除缓存中的组件

```js
function pruneCacheEntry (cache, key, keys, current) {
  const entry = cache[key]
  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy()
  }
  cache[key] = null
  remove(keys, key)
}
```

## 监听include和exclude的变化

+ 监听include和exclude的值，
+ 如果这两个 prop 有变化的话，则按照最新的 include 和 exclude 更新 this.cache，  将不满足 include、exclude 限制的 缓存vnode 从 this.cache 中移除

```js

  mounted () {
    this.$watch('include', val => {
      pruneCache(this, name => matches(val, name))
    })
    this.$watch('exclude', val => {
      pruneCache(this, name => !matches(val, name))
    })
    
    // 在include不处理
    // 不在exclude，删除

```

pruneCache：如果缓存的组件传入的函数规则内，则将组件从缓存中删除，这里是传入了是否满足include和exclude的判断条件

```js
function pruneCache (keepAliveInstance, filter) {
  const { cache, keys, _vnode } = keepAliveInstance
  for (const key in cache) {
    const cachedNode = cache[key]
    if (cachedNode) {
      const name = getComponentName(cachedNode.componentOptions)
      if (name && !filter(name)) {
        // 删除对应的组件
        pruneCacheEntry(cache, key, keys, _vnode)
      }
    }
  }
}
```

匹配matches 

```js

/**
* 判断name是否在pattern范围内，从而判断组件是否在include或者exclude的范围内
**/
function matches (pattern, name){
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}
```

## render

组件重新渲染时，会执行 render 函数获取对应的 vnode

实现 keep-alive 的功能有两个要点：

+ 缓存组件的 Vue 实例， cache[key].componentInstance
+ 缓存组件上次渲染的真实 DOM

```js

  render () {
    const slot = this.$slots.default //获取keep-alive标签包裹的默认插槽中的元素
    const vnode = getFirstComponentChild(slot) //获取到默认插槽中的第一个组件 vnode（keep-alive只对第一个子元素起作用）
    const componentOptions = vnode && vnode.componentOptions
    if (componentOptions) {
      // 获取组件名称
      const name= getComponentName(componentOptions)
      const { include, exclude } = this
      if ( 
        // 如果当前的组件 name 不在 include 中或者组件的 name 在 exclude 中,则直接返回
        // 不符合include
        (include && (!name || !matches(include, name))) ||
        // 符合exclude
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }
 
      const { cache, keys } = this
      const key = vnode.key == null
        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
        : vnode.key
      if (cache[key]) { 
        //如果缓存中存在当前组件
        //将缓存中的组件实例赋给当前组件实例
        vnode.componentInstance = cache[key].componentInstance 
         //将当前组件key从缓存的keys数组中删除
        remove(keys, key)
        //将当前组件keypush到缓存的keys中，以此来保持该组件在缓存中是最新的
        keys.push(key) 
      } else { 
        //如果缓存中没有当前组件
        //将当前组件放入缓存中
        cache[key] = vnode 
        //将当前组件key放入缓存keys数组中
        keys.push(key) 
        if (this.max && keys.length > parseInt(this.max)) { 
          //如果已缓存的组件数量大于max值，则将缓存keys数组中第一个组件删除掉。（缓存中组件的顺序是不常用的在前面，常用的在后面，这是由上面代码中如果组件在缓存中，就需要先在缓存中删除组件key，再重新向缓存keys数组中推入组件key的实现方式决定的）
          pruneCacheEntry(cache, keys[0], keys, this._vnode)
        }
      }
 
      vnode.data.keepAlive = true 
      //标记该组件的keepAlive状态，这对 vnode 有一个标识的作用，标识这个
      // vnode 是 keep-alive 组件的 render 函数 return 出去的，这个标识在下面的运行代码中有用
    }
    return vnode || (slot && slot[0]) //如果上面方法没执行，则直接返回vnode或第一个子元素
  }
```

