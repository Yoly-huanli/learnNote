[toc]

# reactive响应式

例子:

```vue
 setup() {
    let a = reactive({
      age: 1,
      name:'hello'
    });
    setInterval(() => {
      a.age += 1;
    }, 500);
    let b = computed(()=>{return a.age + 5 })
    return {
      b,
    };
  },
```

内部原理：

+ reactive可以把一个对象a进行包裹，变成响应式的对象
+ b变量依赖于a变量的age的值
+ 当获取到a的age变化时，b重新执行函数age+5从而实现随着a的变化而变化

![image-20220422141210831](../../img/image-20220422141210831.png)

## 1.reactive包裹

reactive内主要功能是把原对象利用proxy变成响应式对象，并且要执行依赖搜集和依赖被触发后的操作

```tsx
// reactive.ts
export function reactive(obj:any){
  return new Proxy(obj,{
    get(target,key){
      const res = Reflect.get(target,key)
      // effect内函数触发依赖搜集
      return res
    },
    set(target,key,value){
      const res = Reflect.set(target,key,value)
      // 依赖执行
      return res
    }
  })
}
```

并且可以确认的是，被包裹变为响应式对象后和原对象是不同的,但是还是可以执行get和set操作

```tsx
import {reactive} from './../reactive';
describe('reactive',()=>{
  it('创建reactive对象',()=>{
    const a={name:'yoly',age:1}
    const reactiveA= reactive(a)
    expect(a).not.toBe(reactiveA)
    expect(reactiveA.name).toBe('yoly')
  })
})
```

## 2.effect操作

effect主要操作就是可以触发内部的函数立即执行

```tsx
import {effect} from './../reactive';
import {reactive} from './../reactive';
describe('effect',()=>{
  it('efffect执行',()=>{
    const a={name:'yoly',age:1}
    const reactiveA= reactive(a)
    let nextA
    effect(()=>{
      nextA = reactiveA.age + 5
    })
    expect(nextA).toBe(6)

  })
})
```

```tsx
// effect.ts
export function effect(fn){
 fn()
}
```

可以把立即执行的函数过程抽离出来

```tsx
class ReactiveEffect{
  private _fn:any;
  constructor(fn){
    this._fn = fn
  }
  run(){
    this._fn()
  }
}

export function effect(fn){
 const effectObj = new  ReactiveEffect(fn)
 effectObj.run()
}
```

## 3.依赖搜集

+ reactive.ts在get里触发依赖搜集

```tsx
get(target,key){
      const res = Reflect.get(target,key)
      // effect内函数触发依赖搜集
      track(target,key)
      return res
    },
```

+ effect里写具体的track函数，因为要保存执行的函数，这个函数在effect里才有,考虑为空的情况，最终将依赖搜集为{target:{key:[fn]}}的形式

```tsx
var Fn //全局变量，用于保存可执行对象effectObj

class ReactiveEffect{
  private _fn:any;
  constructor(fn){
    this._fn = fn
  }
  run(){
    Fn = this //指向的就是effectObj
    this._fn()
  }
}

// 依赖搜集
const targetMap = new Map()
export function track(target, key) {
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  let deps = depsMap.get(key)
  if (!deps) {
    deps = new Set()
    depsMap.set(key, deps)
  }
  deps.add(Fn)

export function effect(fn){
 const effectObj = new  ReactiveEffect(fn)
 effectObj.run()
}
```

+ 其中，这个传入进来的fn是需要可以可以立即执行的，这里传入effectObj这个对象，并把它作为依赖搜集里实际保存的值，所以童年过全局变量Fn保存这个effectObj对象，并且存放在依赖里

## 4.触发依赖执行

当函数执行时，a.age=a.age+5, a.age会触发get，依赖搜集之后，紧接着赋值操作，会触发set，此时进行值的更新，从而实现响应式的更新

```tsx
//reactive.ts里进行依赖执行
set(target,key,value){
      const res = Reflect.set(target,key,value)
      // 依赖执行
      trigger(target,key)
      return res
    }
```

那么在effect.ts里进行依赖触发，更新值的操作

```tsx
//执行target对应key上的所有函数
export function trigger(target,key){
  let FnArr = targetMap.get(target).get(key)
  for(const itemFn of FnArr){
    itemFn.run()
  }
}
```

