[toc]

# 垃圾回收

JS具有自动垃圾回收机制，也就是，执行环境会负责管理代码执行过程中使用的内存，哪个变量不再使用就释放它的内存，而且这个垃圾回收是一个周期性的过程，不是实时去搜集与清除

## 垃圾回收方式

### 引用计数

刚开始一些浏览器所使用的垃圾回收方式，主要思路是

```
跟踪记录每个值被引用的次数，引用次数为0，删除释放
```

但是可能存在循环应用的情况，引用次数永远不为0，此时只能将存在循环饮用的值手动设置为null

### 标记清除(常用)

> 垃圾收集器在运行的时候会给存储在内存中的**所有变量**都加上标记（可以使用任何标记方式）。然后，它会去掉**环境中的变量以及被环境中的变量引用的变量的标记**。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

简单理解就是会执行完成之后把值类型的变量都删掉，然后对于引用类型，如果引用来一个被删掉的值，那么它本身就是应该被删掉的

## 性能

垃圾回收机制触发频率会影响性能，触发太频繁或者太慢都会造成影响，将内存占用保持在一个较小的值可以让页面性能更好，而且又一些浏览器对于频繁被调用的函数会更频繁的执行垃圾回收机制

## 内存泄漏

内存泄漏对于内存非常有限的移动设备是非常重要的

### 场景与解决方法

#### 1.意外的全局变量

```js
function foo(arg) {
    bar = "this is a hidden global variable";
}
//或者this
function foo() {
    this.variable = "potential accidental global";
}
// foo 调用自己，this 指向了全局对象（window）
foo();
```

此时，全局变量挂载到了window下，只要window对象没有被清除，这些变量就一直存在

```
1.使用 'use strict'，可以避免此类错误发生
2.函数内部尽量使用let,const,不要使用全局变量
```

#### 2.被遗忘的计时器或回调函数

如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放。

```js
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        // 处理 node 和 someResource
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
```

解决方法

```js
var someResource = getData();
var fn = function() {
    var node = document.getElementById('Node');
    if(node) {
        // 处理 node 和 someResource
        node.innerHTML = JSON.stringify(someResource));
    }
}
var timeCount = setInterval(fn, 1000);

if( timeCount){
   clearInterval(fn)
}
```

#### 3.闭包

name的引用一直存在

```js
let outer = function(){
  let name = "yoly"
  return function(){
    return name
  }
}
```

#### 4.没有清理的DOM元素引用

有时，保存 DOM 节点内部数据结构很有用。
假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除

```
var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
};
function doStuff() {
    image.src = 'http://some.url/image';
    button.click();
    console.log(text.innerHTML);
}
function removeButton() {
    document.body.removeChild(document.getElementById('button'));
    // 此时，仍旧存在一个全局的 #button 的引用
    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。
}
```

## vue中的场景

+ 组件销毁时全局变量、函数未清除
+ 自定义事件未清除
+ 被全局事件、计时器引用未清除  setInterval，clearInterval，addEventListener,removeEventListener
+ 解决方法，在beforeDestroy/beforeUnmount清除

### 识别方法

在chrome的performance中查看，如果是一直上升的，就存在内存泄漏，如果是周期性增加与减少就是正常在执行垃圾回收机制

## weakMap/weakSet

弱引用，也就是引用不计数，所以它们本身也没有size方法，不能用for...of遍历，因为它们不确定自己有多少个元素是可以获取到的,例如:当函数fn执行后，函数内部obj引用此时直接销毁，wMap不作为引用次数

```js
  const wMap = new WeakMap()
  function fn(){
    const obj = {name:'yoly'}
    wMap.set(obj,'Bob')
  }
  fn()
  console.log('wMap', wMap)
```



