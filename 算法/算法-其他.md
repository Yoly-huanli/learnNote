[toc]

# 1.求连续最多的字符和次数

(1)嵌套循环

```js
export function findContinuousChar1(str: string): IRes {
    const res: IRes = {
        char: '',
        length: 0
    }
    const length = str.length
    if (length === 0) return res

    let tempLength = 0 // 临时记录当前连续字符的长度
    // O(n)
    for (let i = 0; i < length; i++) {
        tempLength = 0 // 重置
        for (let j = i; j < length; j++) {
            if (str[i] === str[j]) {
                tempLength++
            }
            if (str[i] !== str[j] || j === length - 1) {
                // 不相等，或者已经到了最后一个元素。要去判断最大值
                if (tempLength > res.length) {
                    res.char = str[i]
                    res.length = tempLength
                }

                if (i < length - 1) {
                    i = j - 1 // 跳步
                }

                break
            }
        }
    }

    return res
}

```

(2)双指针

```JS
export function findContinuousChar2(str: string): IRes {
    const res: IRes = {
        char: '',
        length: 0
    }

    const length = str.length
    if (length === 0) return res

    let tempLength = 0 // 临时记录当前连续字符的长度
    let i = 0
    let j = 0

    // O(n)
    for (; i < length; i++) {
        if (str[i] === str[j]) {
            tempLength++
        }

        if (str[i] !== str[j] || i === length - 1) {
            // 不相等，或者 i 到了字符串的末尾
            if (tempLength > res.length) {
                res.char = str[j]
                res.length = tempLength
            }
            tempLength = 0 // reset

            if (i < length - 1) {
                j = i // 让 j “追上” i
                i-- // 细节
            }
        }
    }

    return res
 }
```

# 2.移动0到数组末尾

[leetcode [283. 移动零](https://leetcode.cn/problems/move-zeroes/)]

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

要求：在原数组的基础上修改，不能使用新数组

+ 思路1：循环一次，是0则push到数组末尾，然后把当前位置0通过splice删除掉

  ```js
  var moveZeroes = function(nums) {
     for(let i = 0, zerolen = 0; i<nums.length-zerolen;i++){
         if(nums[i]===0){
             nums.push(nums[i])
             nums.splice(i,1)
             i--
             zerolen++
         }
     }
  };
  ```

  + 该方法时间复杂度是O(n^2)，一次是循环，一次是splice，数组是有序存储的，当一个位置元素被删除之后，它后边的元素都要往前挪动一个位置，也就是splice本身在删除的时候复杂度就是O（n）
  + zerolen末尾补0的个数，确定是补进去的0，就不需要再次循环遍历了
  + i--，splice之后要往回挪动一次，抵消splice的影响

+ 考虑另一种思路，双指针，j指向第一个0的位置，i指向j之后第一个不为0的位置，交换位置，然后j继续向后移动，此时时间复杂度为O（n）

  ```js
  var moveZeroes = function(nums) {
     let i;
     let j =-1;
     for(let i=0;i<nums.length;i++){
         if(nums[i]===0 && j<0){
             j=i
         }
         if(nums[i]!==0 && j>=0){
             const n = nums[i]
             nums[i]= nums[j]
             nums[j]=n
             j++
         }
     }
  };
  ```

# 3.**和为S的两个数字**

[**JZ57**]

输入：

```
[1,2,4,7,11,15],15
```

返回值：

```
[4,11]
```

思路：**递增序列**，使用双指针

```js
function FindNumbersWithSum(array, sum)
{
    if(array.length===0){
        return []
    }
    let leftHead = 0
    let rightHead = array.length-1
    while(leftHead<rightHead){
        if(array[leftHead]+array[rightHead]===sum){
            return [array[leftHead],array[rightHead]]
        }
        if(array[leftHead]+array[rightHead]<sum){
        leftHead=leftHead+1
        }
        if(array[leftHead]+array[rightHead]>sum){
            rightHead=rightHead-1
        }
    }
    return []
}
```

# 4.左旋转字符串

【JZ58】S = ”abcXYZdef” , 要求输出循环左移 3 位后的结果，即 “XYZdefabc” ，"aab",10输出"aba"

【思路】：计算需要移动的数量，切割并拼接

```js
function LeftRotateString(str, n)
{
    if (!str){
        return ''
    }
    if(str.length === 0 || n===0){
        return str
    }
    let num = n % str.length
    let leftSubStr = str.slice(0, num)
    let rightSubStr = str.slice(num)
    return rightSubStr+leftSubStr
}
```

# 5.寻找1-100以内所有回文数

回文数：121

解法1：通过字符串判断

```js
function findNumber(max){
       let arr =[]
       for(let i =1;i<=max;i++){
         if((i+'').split('').reverse().join('')===i+''){
            arr.push(i)
         }
       }
       return arr
     }
```

解法2：数字直接反转

```js
function findNumber2(max){
       let arr =[]
       for(let i =1;i<=max;i++){
         // 比如1234直接反转为4321
         let n = i
         let revNumber = 0
         while(n>0){
           revNumber = revNumber*10 + n%10
           n = Math.floor(n/10)
         }
         if(i === revNumber){
           arr.push(i)
         }
       }
       return arr
     }
```

性能比较:

```js
console.time('findNumber')
console.log('findNumber', findNumber(100)) //0.810302734375 ms
console.timeEnd('findNumber')

console.time('findNumber2')
console.log('findNumber2', findNumber2(100)) //0.345947265625 ms
console.timeEnd('findNumber2')
```

结论：尽量不要去改变原有的数据结构

# 6.LRU

```js
export default class LRUCache {
    private length: number
    private data: Map<any, any> = new Map()

    constructor(length: number) {
        if (length < 1) throw new Error('invalid length')
        this.length = length
    }

    set(key: any, value: any) {
        const data = this.data

        if (data.has(key)) {
            data.delete(key)
        }
        data.set(key, value)

        if (data.size > this.length) {
            // 如果超出了容量，则删除 Map 最老的元素
            const delKey = data.keys().next().value
            data.delete(delKey)
        }
    }

    get(key: any): any {
        const data = this.data

        if (!data.has(key)) return null

        const value = data.get(key)

        data.delete(key)
        data.set(key, value)

        return value
    }
}
```

