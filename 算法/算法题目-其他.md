[toc]

总体思路：

凡是需要O（n^2）实现的算法，都可以考虑双指针

# 1.左旋转字符串

【JZ58】S = ”abcXYZdef” , 要求输出循环左移 3 位后的结果，即 “XYZdefabc” ，"aab",10输出"aba"

【思路】：计算需要移动的数量，切割并拼接

```js
function LeftRotateString(str, n)
{
    if (!str){
        return ''
    }
    if(str.length === 0 || n===0){
        return str
    }
    let num = n % str.length
    let leftSubStr = str.slice(0, num)
    let rightSubStr = str.slice(num)
    return rightSubStr+leftSubStr
}
```

# 2.反转链表

【JZ24】反转链表

![image-20220425013312563](../img/image-20220425013312563.png)

思想：每次把下一个指向next暂存起来避免指向丢失

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    let pre = null
    let cur = pHead
    while(cur){
        let next = cur.next
        cur.next = pre
        pre = cur
        cur = next
    }
    return pre
}
```

# 3.**和为S的两个数字**

[**JZ57**]

输入：

```
[1,2,4,7,11,15],15
```

返回值：

```
[4,11]
```

思路：**递增序列**，使用双指针

```js
function FindNumbersWithSum(array, sum)
{
    if(array.length===0){
        return []
    }
    let leftHead = 0
    let rightHead = array.length-1
    while(leftHead<rightHead){
        if(array[leftHead]+array[rightHead]===sum){
            return [array[leftHead],array[rightHead]]
        }
        if(array[leftHead]+array[rightHead]<sum){
        leftHead=leftHead+1
        }
        if(array[leftHead]+array[rightHead]>sum){
            rightHead=rightHead-1
        }
    }
    return []
}
```

# 4.移动0到数组末尾

[leetcode [283. 移动零](https://leetcode.cn/problems/move-zeroes/)]

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

要求：在原数组的基础上修改，不能使用新数组

+ 思路1：循环一次，是0则push到数组末尾，然后把当前位置0通过splice删除掉

  ```js
  var moveZeroes = function(nums) {
     for(let i = 0, zerolen = 0; i<nums.length-zerolen;i++){
         if(nums[i]===0){
             nums.push(nums[i])
             nums.splice(i,1)
             i--
             zerolen++
         }
     }
  };
  ```

  + 该方法时间复杂度是O(n^2)，一次是循环，一次是splice，数组是有序存储的，当一个位置元素被删除之后，它后边的元素都要往前挪动一个位置，也就是splice本身在删除的时候复杂度就是O（n）
  + zerolen末尾补0的个数，确定是补进去的0，就不需要再次循环遍历了
  +  i--，splice之后要往回挪动一次，抵消splice的影响

+ 考虑另一种思路，双指针，j指向第一个0的位置，指向j之后第一个补位0的位置，交换位置，然后j继续向后移动，此时时间复杂度为O（n）

  ```js
  var moveZeroes = function(nums) {
     let i;
     let j =-1;
     for(let i=0;i<nums.length;i++){
         if(nums[i]===0 && j<0){
             j=i
         }
         if(nums[i]!==0 && j>=0){
             const n = nums[i]
             nums[i]= nums[j]
             nums[j]=n
             j++
         }
     }
  };
  ```

  

  

