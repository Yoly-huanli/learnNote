[toc]

# 监控告警是怎么做的









### 之前的监控告警是怎么做的

> 分为两部分，第一部分为日志的埋点和上传，包含了代码日志和业务日志。主要是自己实现了一个基于`WebSocket`的日志服务，在客户端项目加载的时候启动`WebSocket`，然后通过提供的log方法在代码中去进行日志打点。服务端收到上传的日志之后传入到公司内的数仓，之后通过数仓的API实现日志的查询。 
> 对于业务数据的埋点则是在对应的用户操作时进行埋点上报。 
>
> 另一部分则是告警的实现，这部分利用公司的统一基础设施去做。在拿到前面的埋点信息之后，在公司的告警平台可以看到对应的埋点数据的趋势图，根据趋势可以设置告警阈值。告警阈值主要是通过人工去指定告警策略并根据实际情况进行调整和优化，以实现更准确的告警。

### 怎么去监控业务指标情况

> 根据业务流程中对应环节的埋点数据可以计算出业务指标，如`提单成功率` = `支付成功的埋点数` / `购物车页点击下单的埋点数`。获取到各个业务指标的计算公式之后，可以在告警平台去配置对应的趋势图，之后按照前面的方式设置监控和告警即可。



作者：Helianthuswhite
链接：https://juejin.cn/post/7298218459795734582
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 小程序性能优化做了哪些事

> 小程序本身是双线程架构，渲染层和逻辑层相互独立，通过微信原生中的`JSBridge`进行通信，因此性能的损耗主要花费在通信过程中。而在通信过程中影响性能的点最主要的则是`setData`的`频率`和`数据量`。 
> 所以主要做的优化手段就是去减少`setData`的次数，同时当`setData`数据量过大时对数据量进行拆分，分为多个`setData`去执行，从这两者中找到一个平衡。 
>
> 除此之外，还利用了Wxml节点压缩，CSS样式合并，以及请求预加载等方式进行性能优化。



作者：Helianthuswhite
链接：https://juejin.cn/post/7298218459795734582
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 富文本编辑器是如何实现的

> 一开始是通过`slate.js`去实现的，`slate.js`提供了富文本编辑器的核心能力，基于这些核心能力我们可以在上层实现各种复杂的富文本编辑器。但是随着业务对富文本编辑器的功能需求越来越多，我们就需要在`slate.js`上投入更多的人力去开发这些新的功能需求，这显然在我们这样的小团队中是不太现实的。于是就考虑找一款功能完善的富文本编辑器，最后选择了`jodit`，一款基于TS实现的富文本编辑器，整体代码比较易读，便于后续对其进行二次开发。



作者：Helianthuswhite
链接：https://juejin.cn/post/7298218459795734582
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 有没有在质量和稳定性上做一些事情

> 包含两部分，一部分是开发过程中的质量保障，主要有两点一个是单元测试，通过`Jest`去实现，另一个则是UI的自动化测试，通过`cypress`实现。第二部分是对线上稳定性的监控，这个是基于开源项目加二次开发实现的。具体可以分为以下几个步骤：
>
> 1. 异常捕获：对异常进行分类，不同分类通过不同的方式进行捕获，如`addEventListener('error')`监听JS代码异常，`window.onerror`监听资源加载异常，`xhr.addEventListener('error')`监听请求异常等
> 2. 异常上报：可以通过`WebSocket`进行上报，或者直接通过`HTTP`请求上报，在上报的时候需要考虑到弱网的缓存，以及高并发的数据合并情况
> 3. 数据接收：启动一个`Node`服务，在接收到异常数据之后直接存在数据库中即可
> 4. 数据使用：对上传的异常和监控数据进行分类查询，并提供对应的监控告警机制，当超出阈值范围时发送告警邮件



作者：Helianthuswhite
链接：https://juejin.cn/post/7298218459795734582
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 【代码题】描述下列代码的输出结果和原因

```js
js
复制代码//  最害怕这种题目了，总是想不明白，一开始说了结果是3，后来面试官让我再想想
//  仔细缕了一下后发现，fn() 里的函数声明虽然会提前，但不会提前到最外层，只会到 fn() 的顶层
//  里面的 foo = 3 修改的其实是里面函数的那个声明，不会影响到外部，所以最终的结果应该是 1

var foo = 1;
function fn() {
    foo = 3;
    return;
    funciton foo() {
        // todo
    }
}
fn();
console.log(foo);
```



作者：Helianthuswhite
链接：https://juejin.cn/post/7298218459795734582
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 【代码题】按照版本号由小到大排序

> 样例输入：versions = ['0.1.1', '2.3.3', '0.302.1', '4.2', '4.3.5', '4.3.4.5'] 
> 输出：['0.1.1', '0.302.1', '2.3.3', '4.3.4.5', '4.3.5']

```js
js
复制代码function compareVersions(versions) {
    return versions.sort((a, b) => {
        const tempA = a.split('.');
        const tempB = b.split('.');
        const maxLen = Math.max(tempA.length, tempB.length);
        for (let i = 0; i < maxLen; i++ ) {
            const valueA = +tempA[i] || 0;
            const valueB = +tempB[i] || 0;
            if (valueA  === valueB) {
                continue;
            }
            return valueA - valueB;
        }
        return 0;
    });
}
```



作者：Helianthuswhite
链接：https://juejin.cn/post/7298218459795734582
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





### 在以往的工作经历中有哪些最有成就感的项目

> 详细讲了一下之前做的监控和告警项目，并且如何通过技术手段来推导业务指标，并根据业务指标的监控数据来反推业务的发展。具体技术上的关键点做了详细介绍，但是整体复杂度并不高，主要还是从收益上看属于低成本高收益的项目。



### 为什么又要从现在的公司离开

> 有两个原因：
>
> 1. 团队发展不看好：新换了一个老板，对团队的定位发生了变化，由创新的探索性团队变成了支持性的IT团队，跟自己的期望不符
> 2. 个人发展受限：从技术上来看，产品用户量较少，且复杂度较低，技术上持续在做输出，但是输入很少；从管理上来看，团队规模趋于稳定，后续不会再有更多人让自己来带

### 对自己未来的发展规划是什么

> 也是可以从两个方面来讲，一个走技术路线，一个走管理路线。

> 技术路线：
>
> 1. 对自身已经掌握的技术持续精进，并通过技术手段去回馈团队和业务（如前端架构、异常监控、性能优化、指标体系等）
> 2. 在某一个技术方向上做到突出，能够沉淀出相应方法论，并建设出系统性的平台，在部门及公司内部普及应用
> 3. 保持对新技术的热情，持续扩宽技术广度，对团队的技术栈持续迭代，保持团队整体技术的竞争力

> 管理路线：
>
> 1. 定目标 —— 包含业务支撑、技术成长和团队培养三部分
> 2. 看执行 —— 主要是对现有流程的问题进行梳理，让过程更加规范化、流程化，同时需要发掘高潜，给其空间快速成长
> 3. 拿结果 —— 需要有可量化的具体数据来作为结果的衡量依据

### 【代码题】实现一个拼手气抢红包算法

> 提供了一个`RedPackage`的类，初始化时传入红包金额和个数，需要实现一个`openRedPackage`方法，每调一次都进行一次“抢红包”，并以console.log的形式输出抢到的红包金额。

```js
js
复制代码class RedPackage {
    money = 0;
    count = 0;
    _remain = 0;
    
    constructor(money, count) {
        this.money = money;
        this.count = count;
        this._remain = money;
    }
    
    openRedPackge() {
        //  已经抢完了
        if (this.count <= 0) {
            console.log('红包已经被抢完啦~');
            return;
        }
        
        //  只剩一个红包
        if (this.count === 1) {
            this.count--;
            console.log(this._remain);
            return;
        }
        
        const ratio = Math.random() * (this._remain / this.money);
        //  这里会涉及到一个JS计算精度的问题
        //  正常应该用第三方库或者字符串算法实现一个精准的加减乘除
        //  这里为了简单就这么直接做了
        let youGet = (this.money * ratio).toFixed(2);
        const tempRemain = +(this._remain - youGet).toFixed(2);
        const allLeast = this.count * 0.01;
        
        //  如果剩余的金额不够每人一分钱，那么需要减少本次获得的金额
        if (tempRemain < allLeast) {
            youGet = +(this._remain - allLeast).toFixed(2);
            this._remain = allLeast;
        } else {
            this._remain = tempRemain;
        }
        console.log(youGet);
        this.count--;
    }
```



作者：Helianthuswhite
链接：https://juejin.cn/post/7298218459795734582
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





### 代码题】数字转字符串

> 样例输入：1234567890 
> 样例输出：1,234,567,890

```js
js
复制代码function toString(num) {
    //  这是最简单的写法
    //  return num.toLocaleString();
    const result = [];
    const str = `${num}`.split('').reverse();
    for (let i = 0; i < str.length; i++) {
        if (i && i % 3 === 0) {
            result.push(',');
        }
        result.push(str[i]);
    }
    return result.reverse().join('');
}
```



作者：Helianthuswhite
链接：https://juejin.cn/post/7298218459795734582
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





### 画一个自己做过的最复杂项目的架构图